-- @path SOAML=/BPMN2SOAML/BPMN2SOAML/OUT/soaMl.ecore
-- @nsURI BPMN=http://stp.eclipse.org/bpmn


module BPMN2SOAML3;
create OUT: SOAML from IN: BPMN;

--helper def: vertice: BPMN!Pool =
--	let allVertex : Sequence(BPMN!Vertex) = BPMN!Vertex.allInstances().asSequence() in
--	allVertex


entrypoint rule Metamodel() {
	to
		t: SOAML!Model (
			packagedElement <- BPMN!BpmnDiagram.allInstances() -> collect(a | thisModule.r0(a))
			--packagedElement <- BPMN!Pool.allInstances() -> collect(a | thisModule.r1(a))
		)
	do {	thisModule.Model <- t;	}
}


lazy rule r0{
	from
		X0: BPMN!BpmnDiagram
	to
		Y0: SOAML!Collaboration (
			name <- X0.name
		),
		Z0: SOAML!ServicesArchitecture (
			baseCollaboration <- Y0
		)
}




rule r1
{
	from
	X1 :BPMN!Pool
	to
	Y1 : SOAML!Class (name <- X1.name),
	Z1 : SOAML!Participant (baseClass <- Y1)
	do
	{
		thisModule.r2(X1,Y1);
	}
	
}


rule r2(X1: BPMN!Pool,Y1: SOAML!Class)
{
	do
	{
		for (c in BPMN!Pool.allInstances())
		{
			if (X1 <> c)
			{
				for (i in X1.vertices)
				{
					if (i.outgoingMessages.size() > 0)
					{
						thisModule.r3(X1,i,c,Y1);
					}
				}
			}
		}
	}
}


rule r3(X1: BPMN!Pool,X2:BPMN!Vertex,X3:BPMN!Pool,Y1:SOAML!Class)
{
	do
	{
		for (c in X3.vertices)
		{
			for (i in X2.outgoingMessages)
			{
				for (j in c.incomingMessages)
				{
					if (i = j)
					{
						thisModule.r4(i,Y1);
					}
				}
			}
		}
	}
}

rule r4(X1:BPMN!MessagingEdge,Y1:SOAML!Class)
{
	to
	Q1 : SOAML!CollaborationUse (name <- X1.name),
	T1 : SOAML!Usage (supplier <- Q1, client <- Y1),
	R1 : SOAML!ServiceContract (collaborationUse <- Q1)
}








--rule r2(X1: BPMN!Pool,X2: BPMN!Vertex,X3: BPMN!Pool,X4: BPMN!Vertex)
--{
--	do
--	{
--		X2.toString().println();
--		for (c in X2.outgoingMessages)
--		{
--			X4.toString().println();
--			for (i in X4.incomingMessages)
--			{
--				
--				if (c = i)
--				{
--					thisModule.r3(X1,X3,c);
--				}
--			}
--		}
--	}
--}
--
--rule r3(X1: BPMN!Pool,X2: BPMN!Pool, X3: BPMN!MessagingEdge)
--{
--	to
--		Y1 : SOAML!Class (name <- X1.name),
--		Y2 : SOAML!Class (name <- X2.name),
--		Z1 : SOAML!Participant (baseClass <- Y1),
--		Z2 : SOAML!Participant (baseClass <- Y2),
--		Q1 : SOAML!CollaborationUse (name <- X3.name),
--		T1 : SOAML!Usage (supplier <- Q1, client <- Y1),
--		T2 : SOAML!Usage (supplier <- Q1, client <- Y2),
--		R1 : SOAML!ServiceContract (collaborationUse <- Q1)
--		do{
--			Sequence{Y1,Y2,T1,T2};
--		}
--}























--lazy rule r2
--{
--	from
--	X1: BPMN!Pool
--	to
--	Y1: SOAML!Class (name <- X1.name),
--	Z1: SOAML!Participant (baseClass <- Y1)
--	do
--	{
--		if (X1.vertices.size() > 0)
--		{
--			thisModule.r3(X1,1,Y1);
--		}
--	}
--}
--
--
--rule r3(X1: BPMN!Pool,n: Integer,X2: SOAML!Class)
--{
--	do
--	{
--		if (n < X1.vertices.size()+1)
--		{
--			if (X1.vertices.at(n).outgoingMessages.size() > 0)
--			{
--				thisModule.r5(X1.vertices.at(n),1,X2);
--			}
----			if (X1.vertices.at(n).X1.incomingMessages.size() > 0)
----			{
----				thisModule.r4(X1.vertices.at(n),1,X2);
----			}
--			thisModule.r3(X1, n+1);
--		}
--	}
--		
--}
--
----rule r4 (X1: BPMN!Vertex,n: Integer,X2: SOAML!Class)
----{
----	do
----	{
----		if (n < X1.incomingMessages.size()+1)
----		{
----			thisModule.r6(X1.outgoingMessages.at(n),X2);
----			thisModule.r5(X1, n+1);
----		}
----	}
----}
----
----
----rule r7(X1: BPMN!MessagingEdge,X2: SOAML!Class)
----{
----	to
----}
--
--
--rule r5(X1: BPMN!Vertex,n: Integer,X2: SOAML!Class)
--{
--	do
--	{
--		if (n < X1.outgoingMessages.size()+1)
--		{
--			thisModule.r6(X1.outgoingMessages.at(n),X2);
--			thisModule.r5(X1, n+1);
--		}
--	}
--}
--
--rule r6(X1: BPMN!MessagingEdge,X2: SOAML!Class)
--{
--	to
--	Q1: SOAML!CollaborationUse(name <- X1.name),
--	T2 : SOAML!Usage (supplier <- Q1, client <- X2),
--	R1 : SOAML!ServiceContract (collaborationUse <- Q1)
--}


--module BPMN2SOAML3;
--create OUT: SOAML from IN: BPMN;
--
--entrypoint rule Metamodel() {
--	to
--		t: SOAML!Model (
--			packagedElement <- BPMN!BpmnDiagram.allInstances() -> collect(a | thisModule.
--					r0(a)),
--			packagedElement <- BPMN!Pool.allInstances() -> collect(a | thisModule.r1(a)),
--			packagedElement <- BPMN!MessagingEdge.allInstances() -> collect(a |
--					thisModule.r2(a))
--		)
--	do {	thisModule.Model <- t;	}
--}
--
--unique lazy rule r0{
--	from
--		X0: BPMN!BpmnDiagram
--	to
--		Y0: SOAML!Collaboration (
--			name <- X0.name
--		),
--		Z0: SOAML!ServicesArchitecture (
--			baseCollaboration <- Y0
--		)
--}
--



--rule r1 (X1: BPMN!Pool){
--to
--		Y1: SOAML!Class (
--			name <- X1.name
--		),
--		Z1: SOAML!Participant (
--			baseClass <- Y1
--		)
--		do {
--			for (c in X1.outgoingMessages) {
--				
--			}
--		}
--}
--
--rule r2 (x : BPMN!MessagingEdge) {
--	to
--		y: SOAML!CollaborationUse (
--			name <- x.name
--		),
--		k: SOAML!Usage (
--			supplier <- y,
--			client <- thisModule.r1()
--		),
--		j: SOAML!Usage (
--			supplier <- y,
--			client <- x.target
--		),
--		z: SOAML!ServiceContract (
--			collaborationUse <- y
--		)
--}
