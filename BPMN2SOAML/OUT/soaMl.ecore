<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0"
    xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="soaMl"
    nsURI="http:///soaMl.ecore" nsPrefix="soaMl">
  <eSubpackages name="bmmIntegration" nsURI="http:///soaMl/bmmIntegration.ecore" nsPrefix="soaMl.bmmIntegration">
    <eClassifiers xsi:type="ecore:EClass" name="BehavioredClassifier" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="subsets ownedElement&#xA;subsets clientDependency"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="MotivationRealization">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="subsets client&#xA;subsets client&#xA;subsets supplier"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="implementingClassifier"
          ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/emf/2002/Ecore#//EObject"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="realizedMotivation" ordered="false"
          lowerBound="1" eType="ecore:EClass http://www.eclipse.org/emf/2002/Ecore#//EObject"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="p3" nsURI="http:///soaMl/p3.ecore" nsPrefix="soaMl.p3"/>
  <eSubpackages name="p2" nsURI="http:///soaMl/p2.ecore" nsPrefix="soaMl.p2"/>
  <eSubpackages name="services" nsURI="http:///soaMl/services.ecore" nsPrefix="soaMl.services">
    <eClassifiers xsi:type="ecore:EClass" name="Agent" eSuperTypes="#//services/Participant">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Agent&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>An agent is an autonomous entity that can adapt to and interact with its environment..&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>An agent is a kind of Participant with some additional characteristics. Agents are autonomous, interactive and adaptative components.&amp;nbsp;They are capable of acting without direct external intervention. They are able to communicate with the environment and other agents. They can learn and evolve over the time.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>No additional semantic.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- I think that we need to better justify the need of this element, because it belongs to a kind of platfrom and therefore it shuold be moved to an extension.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Participant">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Participant&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A Participant (Fig 01.Simple)&amp;nbsp;is a special kind of UML Component and Class&amp;nbsp;that provides or consumes services. It represents an element of the system, or the system itself,&amp;nbsp;that interacts with other entities outside the boundaries of the system. &lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>Participants are used to distinguish regular elements (Components and Classes) from those that maintain relationships with entities outside the boundaries of the system. For example they can be used in the design of a supply chain management system to differentiate those parts, or Components, that exchange information with other organisations. Participants can also be used to identify the different organisations taking part in a complex business transactions.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>As a UML Component the participant represents a modular part of a system &lt;EM>(Fig 01.Simple)&lt;/EM>&amp;nbsp;that encapsulates its contents and whose manifestation is replaceable. In the same way that components&amp;nbsp; can, the Participant can package other UML elements to support its definition and to organise the model &lt;EM>(Fig 09.ComposedParticipant)&lt;/EM>. &lt;/P>&#xD;&#xA;&lt;P>Participants may act as service consumer, providers or both. A participant will act as pure consumer if it only owns Requisitions and no Services &lt;EM>(R 6.5.12.1)(Fig 03.Consumer)&lt;/EM>. On the other hand it will act as a pure&amp;nbsp;provider if it only owns Services and no&amp;nbsp;Requisitions&lt;EM>&amp;nbsp;(R 6.5.13.1)(Fig 02.Provider)&lt;/EM>. &lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Services/Requests)&lt;/EM> When a ConnectableElement (Service or Request) is added to a Participant, this implies that the Participant is able to provide or consume the capabilities defined that ConnectableElement. The capabilities can be specified Interface or ServiceInterface type of the ConnectableElement, or by the Contracts supported by that ConnectableElement. It is important to remark that when the Participant Services a ServiceInterface (or regular UML Interface)&amp;nbsp;that means that the Participant is able to provide the provided interfaces and consume the required interfaces (This is because the Participant is acting as the Providerr of the ServiceInterface). The situation is different when a Participant Request a&amp;nbsp;ServiceInterface. In that case that means that the Participant is able to consume the provided Interfaces and provide the required Interfaces (This is because the Participant is acting as the consumer of the ServiceInterface).&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(ServiceInterfaces)&lt;/EM> The Interfaces or the ServiceInterfaces implemented by the Participant are referenced through ConnectableElements (Services or Requisitions). When a ServiceInterface is pointed through a ConnectableElement that means that the Participant must implement the operations of the ServiceInterface and must comply with the behaviour of the ServiceInterface.&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Contracts)&lt;/EM> Participants can indicate the service contracts they fulfill &lt;EM>(R.6.5.6.1)&lt;/EM> and the roles they implement on those contracts. There are several ways to specify this relationship. It can be done in the context of a service architecture&lt;EM> (Fig 04.ContractFulFillServiceArchitecture)&lt;/EM> or it can be done in the context of a participant &lt;EM>(Fig 05.ContractFulFillParticiopant)&lt;/EM>. The implication of this binding is that the participant should, or must&amp;nbsp;&lt;EM>(R.6.5.6.2)&lt;/EM> (in case the Contract is Strict),&amp;nbsp;&amp;nbsp;implement all the responsabilities specified in the contract for the linked role. For example, if the role type is a service interface, the participant should (or must)&amp;nbsp;provide that service&amp;nbsp;interface complying with the behaviour of the contract. If the role type is a participant, this participant should (or must)&amp;nbsp;provide all the features of that participant complying with the behaviour of the contract. &lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Behaviour)(R6.5.14.1)(R6.5.14.1)&lt;/EM> Participant can include behavioural descriptions to describe the way in which the different Services and Requisitions are executed to complete the objective of the Participant. This specification do not constrain the way to describe the behaviour of the component.&amp;nbsp;Any UML behavioural specification method can be used to describe the activity of the Participant. This includes, but not&amp;nbsp;is not limited to,&amp;nbsp;activities, interactions, state machines, protocol state machines, and/or opaque behaviours &lt;EM>(Fig 06.Behaviuor)(09.BehaviourOperation)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- I use composition following the same approach that the one used between port and structuredclassifier and the same that the one between encapsulatedclassifier ans port. Latter in the profile we use the shared agregation because otherwise, if we use composition, it marks it as an error&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- Why the requisitions&amp;nbsp; and services properties are derived?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- R.6.5.6.2 I think that what is strict is the binding not the contract or the collaboration use. In the requirements for contracts there are no references to strict attributes. Therefore I will propose to add a new element &lt;STRONG>ContractFulfillment&lt;/STRONG> to gather that information.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- In the metamodel it inherits form component and Class but in the profile it only inherits from component. In which sceparios do we need to use classes instead of components.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- should we add something in the description to reflect that the way in which those properties (requsitions and services)&amp;nbsp;are derived are the same ones that the ports for the encasulatingClassifiers in UML&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;P>&amp;nbsp;&lt;/P>&lt;/BODY>&lt;/HTML>&#xA;subsets clientDependency&#xA;subsets ownedElement"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Attachment">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Attachment&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A part of the message&amp;nbsp;that has its own identity and which is separable from the main message. Attachments are usually created and processed by components or applications external to the participants in the service.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>The objective of Attachment is to allow the definition of elements in the messages that have their own identity and which are separable from the main message. Examples of attachments can be images, word&amp;nbsp;documents, pdf documents, or music samples. &lt;/P>&#xD;&#xA;&lt;P>Attachments are usually created by external applications and are expected to be processed by external applications. &lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>An attachment is an specialization of Property.&amp;nbsp;It helps to distinguish between regular attributes that usually have an asociated dataype and attachments. Attachments are usually transmited in binnary format following a given encoding scheme. The encoding scheme can be defined in the encoding attribute.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semanticVariation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- no&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="encoding" ordered="false"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="mimetype" ordered="false"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="MessageType">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>MessageType&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>.MessageTypes identify the information that is exchanged between services providers and consumers.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>A MessageType allows to explicitly identify the information to be exchanged through the services. Their usage is optional, as it is also possible to identify the messages exchaged from the signature of the operations of the ServiceInterfaces.&lt;/P>&#xD;&#xA;&lt;P>Their usage can be useful to identify those information structures that are specially sensible, and which cannot be changed without affecting the interaction of the Participant with other Participants. &lt;/P>&#xD;&#xA;&lt;P>MessageTypes can be used to describe input, output and exception messages.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- I am not too sure about the need for this element, I am almost sure that we can use classes to describe the information exchaged, with only one doubt: the references.&amp;nbsp;Ussually, the objects are passed as references, but that&amp;nbsp;is to useful in services. We can use this messageType to reflect that the object is pass by value. The next question then, is what happens with the&amp;nbsp;objects referenced from the object...&amp;nbsp;&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- maybe it can be useful to explicitly identiy the messages exchanged by the services and the requisitions.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="encoding" ordered="false"
          eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Milestone">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Milestone&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A Mileston isa means for depicting progress in behaviours in order to analyse liveness. Milestones are particularly useful for behaviours that are long or even infinite.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>A milestone depicts progress by defining a signal that is sent to an imaginary observer. The signal contains an integeer vaule that intuitibelu represents the amount of progress that hass been achieved when passing a point attached to this milestone.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>The milestones are used to annotate certaint points in the bahavioural descriptions of the services.They can be used in the behavioural description of the ServiceArchitectures, ServicesContracts, Participants and ServiceInterfaces.&lt;/P>&#xD;&#xA;&lt;P>The Milstone can be understood as a signal. The signal is sent to an observer each time that a point connected to the Milestone is passed during execution. The implementation of the Milestones in the final execution environment is not mandatory, it is only advisable in those cases where there is an interest on monitoring the progress of the execution of certain behaviours.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- interesting but maybe not central to the objective of the metamodel. Maybe another extension on monitoring.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="progress" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="signal" ordered="false"
          eType="ecore:EClass http://www.eclipse.org/emf/2002/Ecore#//EObject"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="value" ordered="false"
          upperBound="-1" eType="ecore:EClass http://www.eclipse.org/emf/2002/Ecore#//EObject"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Property">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Property&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A .&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>The objective of .&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>A .&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semanticVariation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- Why? What is the scenariy that is being addrssed?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="isId" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="false"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Capability">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>ServiceCapability&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A ServiceCapability provides a simple way to discover and deocument a portfolio of services.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>ServiceCapability&amp;nbsp; may specify its capabilities using Operations or realized Intefaces, and may contain ownedBehaviors indicating how the service capabilities might be implemented in order to discover and identify other services.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>A ServiceCapability may realize interfaces, or contain operations that list the necessary service capabilities. A ServiceCapability may also have ownedBehaviors which may be used to indicate how other ServiceCapability might be expected to be used to implement the service capabilities. These are primarily used to identify and document services. &lt;/P>&#xD;&#xA;&lt;P>A ServiceCapability is connected to ServiceInterfaces or Participants that realize it through a UML2 Realization. Like any other classifier, a ServiceCapabiltiy may be marked as a specification which may or may not be realized by some implementing ServiceCapability. &lt;/P>&#xD;&#xA;&lt;P>A ServiceCapability may also be used as a part in a Participant to which its services may be delegated for implementation purposes.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semanticVariation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- what is this for? It seems the ServiceInterface with &amp;lt;&amp;lt;specification&amp;gt;&amp;gt; stereotype&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Request" eSuperTypes="#//services/Port">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Request&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A ConnectableElement through which a participant receives and provides all the information it needs to be able to provide its services.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>The objective of the Request element is to make it possible to distinguish the main service or services of the Participant and those who are required in order to be able to provide the main services. For example a Purchasing company main service is the PurcheaseService, but in order to provide that service it may require other external services such as Invoicing, Scheduling or Shipping services &lt;EM>(Fig Participant.Example.09.BehaviourOperation)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>A Request inherits from&amp;nbsp;ConnectableElement.&amp;nbsp;It is a ConnectableElement that can provide and request operations to external entities. It redefines the isUsage attribute of the ConnectableElement to true. That means that the Participant who owns the request is action as the consumer of the services.&lt;/P>&#xD;&#xA;&lt;P>More concretely, if the type of the Request is an Interface, the Participant must be able to consume that interface. In that case the Interface will be required by the ConnectableElement.&amp;nbsp; If the type of the&amp;nbsp;Request is a ServiceInterface, it means that the Interfaces realized by&amp;nbsp;the ServiceInterface will be&amp;nbsp;required by the ConnectableElement, and the Interfaces used by the ServiceInterface will be provided by the ConnectableElement&amp;nbsp;.It is important to note that this semantic differs from the standard UML semantics for port and its types.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semantic variations points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- If the request inherits from connectable element it does not inherit the provided and requred attributes from the port metaclass. Should we include an inheritance to Port? I think that possibly yes.&lt;STRONG> -&amp;gt; No, because we need to be able to define the behaviour among the different requested and provided interfaces.&amp;nbsp;Port is not a classifier and therefore it cannot &amp;nbsp;define behaviour. We specify the behaviour through the type property of the UML:::connectableElement which inherits from UML:::TypedElement. A minor drawback, or consequence, is that we have to include an association between the participant and the request.&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- There are 3 ways to relate a ServiceInterface with a UML:::Port the type, the provide and the require attributes. I think that we should avoid the use of the type In the same way UML does, and focus in provide and require. &lt;STRONG>-&amp;gt; We use the type in order to be able to define behavior among the different interfaces.&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- UML:::Port has an attribute call isService, it covers some, but not all the needs of our standards, Should we explain this somewhere? &lt;STRONG>-&amp;gt; We do not use port, becasue it cannot contain behavioural specification&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- If we include several required and provided interfaces (or service interfaces) to a request. Is it possible to define the behabiour of the port. This is, the sequence in which the operations are invoked. I point this because port is not&amp;nbsp;a classifier and I am not too sure if it can be described with behaviour. &lt;STRONG>-&amp;gt; We do not use port, because it cannot contain behavioural specification&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- why are we using provided and required interfaces asociation, if we can model that with the serviceInterfaces. In fact in rational &lt;STRONG>-&amp;gt; they are derived asociations they are calculated from the realized and used interfaces of the classes that are used as types of the Requests&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- should we add something in the description to reflect that the way in which those properties (provided and required)&amp;nbsp;are derived are almost&amp;nbsp;the same ones used for ports and interfaces in UML. In this case I supose that if the type is an interface that will be required, and if the type is a ServiceInterfaces&amp;nbsp;the interfases realised will be required and the interfaces uded will be provided.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- why are we redefining the type to protocol?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>&#xA;redefines type"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="protocol" ordered="false"
          eType="#//services/ServiceInterface"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Port">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>ConnectableElement:&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>Requests and Services are both ConnectableElements from which information is exchanged with&amp;nbsp;other external entities.&amp;nbsp;The ConnectableElements are not always mandatory and it is possible to specify optional ConnectableElements&amp;nbsp;using the&amp;nbsp;connectorRequired attribute.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>Participants can include one or more ConnectableElements to identify service interaction points. The places from which the services are exchanges can be Services or Requests.&amp;nbsp;Services are ConnectableElements that describe the services provided by the Participant, while Requests are ConnectableElements that describe the services that the Participant must consume in order to be able to provide their Services.&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Attr connectorRequired&lt;/EM> &lt;EM>)&lt;/EM> ConnectableElement&amp;nbsp;provide to Services and Requests with the connectorRequired attribute to indicate whether a connector is required on this connection point. This enable the designer to specify optional services and requests that are not critical&amp;nbsp;for the participant. &lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Attr isUsage)&lt;/EM> ConnectableElement also provides the isUsage attribute that allows to further distinguish between Services and Request. The default&amp;nbsp;value for this attribute is flase, but for Request the default&amp;nbsp;value for these elements is switched to true.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>(Attr connectorRequired)&lt;/EM> When a ConnectableElement, a Service or a request, has the attribute connectorRequired is set to true (the default value) this implies that there must be&amp;nbsp;at least one&amp;nbsp;connector to that ConnectableElement. This means that if the value is true the&amp;nbsp;Service must be consumed or the requestmust be satisfied. &lt;/P>&#xD;&#xA;&lt;P>On the other hand, when the value of connectorRequired is set to false this implies that the Participant is able to work&amp;nbsp;without that Service or request. This may have some implication on the service quality that the Participant should be able to manage.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Attr isUsage)&lt;/EM> When the value of the isUsage (Requests)&amp;nbsp;attribute of a ConnectableElement is set to true it means that the operation provided by the ServiceInterfaces are used and the Interfaces requested by the service interfaces are provided. If the value is false, it means that the provided by the ServiceInterfaces are provided and the Interfaces requested by the service interfaces are requested.&amp;nbsp;&lt;EM>&amp;nbsp;&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(ServiceInterface) (R 6.5.15)(01.OptionalServiceSpecifications)&lt;/EM> The ConnectableElement inherits from UML TypedElement, therefore it has a type attribute. The type of the ConnectableElement determines the capabilities to be provided or requested through it. But the assignment of the type is optional. Therefore, if it is not assigned it means that the specification of the Service or Request&amp;nbsp;may include or not the specification&amp;nbsp;of the interfaces, operations and behaviours to by&amp;nbsp;provided through the ConnectableElement.&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Interface/ServiceInterface) &lt;/EM>A ConnectableElement can be typed with interfaces. It is possible to use regular UML Interfaces or ServiceInterfaces defined in this metamodel. If UML Interfaces are used, it implies that the Participant that owns the ConnectableElement requires that capabilities from external entities, or provides capabilities to external entities. If ServiceInterfaces are used, it means that it will be possible to associate to that ConnectableElement one or more required and provided Interfaces between the provider and the consumer. The sequence of usage of operations of the different interfaces can be described by the ServiceInterface.&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>(Participant)&lt;/EM> When a ConnectableElement (Service or request) is attached to a Participant this means that the Participant is able to provide and process all the interface or the ServiceInterface&amp;nbsp;associated to the ConnectableElement type. It also means that the Participant is able to cope with the roles of the Contracts to which the ConnectableElement is associated through a Role Binding &lt;EM>(02.RoleBindingContract)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semantic variation points are defined&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- Should we add a constraint to restirct the containment of ConnectableElements to Participants?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>-Should we add another constraint to restrict the types to Interfaces (and ServiceInterfaces through inheritance)?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- In the profile if we say that connectable element extends UML ConnectableElement that implies that we could be able to stereotype any ConnectableElement as a requistion or services. This includes not only ports, but properties, etc. Should we avoid this situation?.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- Request and services, both, redefine the type as protocol. maybe it will be more polite to redefine it from the ConnectableElement &lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>-Why we inherit from ConnectableElement and not just from port?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="connectorRequired" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ServiceInterface">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>ServiceInterface&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>Defines the interface to a Service or Request. The ServiceInterface describe the operations used between a serviceProvide and a service Consumer. &lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>ServiceInterface&amp;nbsp;are used to specify the operations involved in a Service interaction. It can also be used to specify the order in which those operations are executed. ServiceInterfaces are used as a type of a Service or Request. A ServiceInterface can require the provision and requisition of operations, therefore a ServiceInterface can imply the implementation and usage of one or more regular UML Interfaces between the service provider and the service consumer.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>As a UML Class&amp;nbsp;the ServiceInterfaces can realise and use other interfaces, this allows to represent complex services that require the bidirectional exchange of information between the provider and the consumer. The ServiceInterfaces are not intended to implement the behaviour and the operations they define. ServiceInterfaces are used for specification purposes, the realisation of the operations and the behaviour is implemented by the concrete Participants.&lt;/P>&#xD;&#xA;&lt;P>ServiceInterfaces do not directly contain operations. The operations provided by the ServiceInterface are described in the operations of the realized interfaces. While the consumed interfaces are described in the operations of the used interfaces &lt;EM>(Fig 01.Operation) (R 6.5.7.1.b)&lt;/EM>. Using UML mechanisms operations can be further described with pre and post conditions, parameters and exceptions &lt;EM>(R 6.5.7.1.c)(R 6.5.7.1.d)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;P>ServiceInterfaces can contain behavioural descriptions to describe the way in which the different provided and required operations are executed to fulfill the objectives of the service &lt;EM>(R 6.5.7.1.f) (Fig 02.Behaviour)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No Semantic variation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- R 6.5.7.1. c I do not see the way to define exceptions &lt;STRONG>-&amp;gt; there is one way operations can point to one or more RaisedExceptions. In RSM this is achived throug the UML Properties of the operation.&lt;/STRONG>&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Metamodel:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>&#xA;subsets clientDependency&#xA;subsets ownedElement"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Service" eSuperTypes="#//services/Port">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Service&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A ConnectableElement through which a participant receives and provides all the information it needs to complete its services.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>The objective of the Service element is to make it possible to distinguish the main service or services of the Participant and those who are required in order to be able to provide the main services. For example a Purchasing company main service is the PurcheaseService, but in order to provide that service it may require other external services such as Invoicing, Scheduling or Shipping services &lt;EM>(Fig Participant.Example.09.BehaviourOperation)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>A Service inherits from&amp;nbsp;ConnectableElement. It is a ConnectableElement that can provide and request operations to external entities. From a conceptual point of view it identifies the interfaces that constitute the objective of the Participant.&lt;/P>&#xD;&#xA;&lt;P>More concretely, if the type of the Service is an Interface, the Participant must be able to provide that interface. In that case the Interface will be provided by the ConnectableElement.&amp;nbsp; If the type of the&amp;nbsp;Service is a ServiceInterface, it means that the Interfaces realized by&amp;nbsp;the ServiceInterface will be&amp;nbsp;provided by the ConnectableElement, and the Interfaces used by the ServiceInterface will be required by the ConnectableElement.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semanticVariation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- similar to those from Request&lt;/EM>&lt;/P>&lt;EM>&#xD;&#xA;&lt;P>&lt;EM>- should we add something in the description to reflect that the way in which those properties (provided and required)&amp;nbsp;are derived are the same ones used for ports and interfaces in UML&lt;/EM>&lt;/P>&lt;/EM>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&#xD;&#xA;&lt;P>&amp;nbsp;&lt;/P>&lt;/BODY>&lt;/HTML>&#xA;redefines type"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="protocol" ordered="false"
          eType="#//services/ServiceInterface"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ServiceContract" eSuperTypes="#//services/Collaboration">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>ServiceContract&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A formalization of a collaboration pattern among different service roles. &lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>ServiceContracts are used to specify interaction patterns based on services. They specify the operations involved in the interaction and the sequence of invocation of those operations.&lt;/P>&#xD;&#xA;&lt;P>Participants and ConnectableElements can be binded to the different roles of the ServiceContracts. These bindings imply the capability of the Participant or the ConnectableElemenyt to fulfill that role.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>As a UML Collaboration the ServiceContract purpose is to describe the interaction among a set of roles. As a UML Collaboration the ServiceContract can also be used to realize UseCases that capture contract requirements &lt;EM>(R 6.5.5.1.c)(Fig 04.UseCaseRealzation)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;P>The role types in a ServiceContract are expected to be Interfaces, ServiceInterfaces, ConnectableElements or Participants &lt;EM>(Fig 03.RolesTypes)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;P>A ServiceContract can also&amp;nbsp;nested in other ServiceContracts. This means that the realisation of the upper level ServiceContract forces the&amp;nbsp;realisation of the nested ServiceContracts.&lt;/P>&#xD;&#xA;&lt;P>Where the a ServiceInterfaces, ConnectableElement or Participant has a behaviour and is also used as a type in a ServiceContract, the behaviour must comply with the ServiceContract. However, common practice would be to specify a behaviour in the ServiceContract or ServiceInterface not both.&lt;/P>&#xD;&#xA;&lt;P>(R6.5.5.1.f) UML Connectors can be used to indicate possible interactions between roles.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No Semantic variation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- Service type must be only an interface? or we can use a Participant specification as a type of role? R6.5.5.1.e&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- isStrict I think that it could be better to put that information on the role binding&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Metamodel:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Collaboration">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>Collaboration&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>This is an auxiliary element to extend the UML collaboration with the isStrictAttribute. This element is latterly extended by the ServiceContract and the ServiceArchitecture which are described in more detail.&amp;nbsp;.&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>No .&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- Is this element really needed?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- are we going tu use it as an element of the profile?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- the Strick would be better used as an extension of the conectors used between the parts and roles and the collaborations?&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>No.&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="isStrict" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ServicesArchitecture" eSuperTypes="#//services/Collaboration">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>ServiceArchitecture&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>A ServiceArchitecture describes how Participants are connected and how they work together.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>ServiceArchitectures are used to conceptually relate sets of Participants that work together providing and consuming services. ServiceArchitectures&amp;nbsp;can be used to identify the Participants that work together with a common propouse and the Contracts that rule their interactions. ServiceArchitectures can be also use to group all the Participants that belong to a given domain or all the participants that belong to the same organisation.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>The SeviceArchitecture is a kind&amp;nbsp; of UML Collaboration and Class, as such, it can be further described with roles, parts and connectors.&amp;nbsp;As a Collaboration&amp;nbsp;it can be latterly used&amp;nbsp;as CollaborationUse inside other architectures, to create grater or extended architectures over the existing&amp;nbsp;ones.&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;P>ServiceArchitecture Inherits&amp;nbsp;the isStrict attribute form the Collaboration, when the isStrict is false it means that is not mandatory to fulfill all the roles and behaviours specified by the ServiceArchitecture.&lt;/P>&#xD;&#xA;&lt;P>The Participants that colaborate in a service architecture are linked using Parts. The type of the Part Element&amp;nbsp;identifies the Participant that the Part represents. It is also possible to include Contracts instances in the ServiceArchitecture. When a Contract is included in the ServiceArchitecture and it is related to a Participant, that implies that the Participant fullfils that Contract &lt;EM>(01.Participants)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;P>Contracts inside the ServiceArchitectures can be linked to Participants or to the ConnectableElements (Services and Request) of the Participants. When a contract is linked to a ConnectableElements it means that the Participant fullfil that contract through that ConnectableElement &lt;EM>(04.ContractsConnectableElement)&lt;/EM>.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No semanticVariation Points.&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- With the profile if we use a component, it is possible to include ConnectableElements (Requisitions and Services Fig 05.ParticipantsComponent) if we use Collaborations (01.ParticipantsCollaboration) that is not possible. If both cases, it is possible to include behaviural descriptions. If we use Component then we cannot use collaboration uses.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- It is absolutelly necessary to force the existance of a compatible port (ConnectableElement)&amp;nbsp;compliant with the serviceContract.&lt;/EM>&lt;/P>&#xD;&#xA;&lt;P>&lt;EM>- if the isStrict attribute tries to provide a response to the R5.6.2 I will prefer to indicate that in the role binding rather than in the Collaboration or the collaboration use. The contract is the contract, is the entitie wo can supoort it&amp;nbsp;in a strict or loose way.&amp;nbsp;&lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Metamodel:&lt;/H2>&#xD;&#xA;&lt;H2>&lt;BR>Profile:&lt;BR>&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;P>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;P>&amp;nbsp;&lt;/P>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="CollaborationUse">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="&lt;HTML>&lt;HEAD>&#xD;&#xA;&lt;META content=&quot;MSHTML 6.00.2900.2180&quot; name=GENERATOR>&lt;/HEAD>&#xD;&#xA;&lt;BODY>&#xD;&#xA;&lt;H1>CollaborationUse&lt;/H1>&#xD;&#xA;&lt;H2>Summary:&lt;/H2>&#xD;&#xA;&lt;P>CollaborationUse are used to represent fullfilment of ServiceContracts and ServiceArchitectures within structuredClassifiers. &lt;/P>&#xD;&#xA;&lt;H2>Description:&lt;/H2>&#xD;&#xA;&lt;P>The objective of a CollaborationUse is to show how a Collaboration (ServiceContracts and ServiceArchitectures) is fullfiled by the different&amp;nbsp;inner parts of a&amp;nbsp;structuredClassifiers. Particularly they are used within .ServiceContracts, ServiceArchitectures, Participants and ServiceInterfaces and are roleBinded to ConnectableElements (services and Request), Interfaces and Participants.&lt;/P>&#xD;&#xA;&lt;P>They can be used to show the roles that the different ConnectableElements of a Participant must comply with. They can also be used to show how ServiceContracts are build on top of other ServiceContracts. They can also be use to show the ServiceContracts implemented in a ServiceArchitecture.&lt;/P>&#xD;&#xA;&lt;H2>Semantics:&lt;/H2>&#xD;&#xA;&lt;P>When we link an element with a CollaborationUse (representing a ServiceContract or ServiceArchitecture) this implies that the linked element must satisfy the specification asociated with the CollaborationUse. This can imply to implement operations, interfaces, and behaviours.&lt;/P>&#xD;&#xA;&lt;H2>Semantic Variation Points:&lt;/H2>&#xD;&#xA;&lt;P>No..&lt;/P>&#xD;&#xA;&lt;H2>Issues:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>- Would it be reasonable to include an element (or rename this one)&amp;nbsp;called fulfillment to the metamodel. &lt;/EM>&lt;/P>&#xD;&#xA;&lt;H2>Examples:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Metamodel:&lt;/H2>&#xD;&#xA;&lt;P>&lt;EM>&lt;/EM>&amp;nbsp;&lt;/P>&#xD;&#xA;&lt;H2>Profile:&lt;/H2>&lt;/BODY>&lt;/HTML>"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="isStrict" ordered="false"
          lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"
          defaultValueLiteral="true"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ServiceChannel"/>
    <eClassifiers xsi:type="ecore:EClass" name="Consumer"/>
    <eClassifiers xsi:type="ecore:EClass" name="Provider"/>
    <eClassifiers xsi:type="ecore:EClass" name="Expose"/>
    <eSubpackages name="diagrams" nsURI="http:///soaMl/services/diagrams.ecore" nsPrefix="soaMl.services.diagrams"/>
  </eSubpackages>
  <eSubpackages name="categorization" nsURI="http:///soaMl/categorization.ecore" nsPrefix="soaMl.categorization">
    <eClassifiers xsi:type="ecore:EClass" name="Catalog"/>
    <eClassifiers xsi:type="ecore:EClass" name="Categorization"/>
    <eClassifiers xsi:type="ecore:EClass" name="Category"/>
    <eClassifiers xsi:type="ecore:EClass" name="CategoryValue"/>
  </eSubpackages>
</ecore:EPackage>
